"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[8117],{584:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"encoders/x265","title":"x265","description":"x265 is a software library and command line application for encoding H.265 / HEVC developed by MulticoreWare, written in C++ and x86 assembly, and released in 2013.","source":"@site/docs/encoders/x265.mdx","sourceDirName":"encoders","slug":"/encoders/x265","permalink":"/docs/encoders/x265","draft":false,"unlisted":false,"editUrl":"https://github.com/av1-community-contributors/codec-wiki/tree/main/docs/encoders/x265.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"x265","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"x264","permalink":"/docs/encoders/x264"},"next":{"title":"x266","permalink":"/docs/encoders/x266"}}');var n=i(4848),r=i(8453);const o={title:"x265",sidebar_position:2},a="x265",d={},l=[{value:"Preset",id:"preset",level:2},{value:"Rate Control",id:"rate-control",level:2},{value:"<code>--CRF</code>",id:"--crf",level:3},{value:"<code>--bitrate</code>",id:"--bitrate",level:3},{value:"Threading",id:"threading",level:2},{value:"<code>--wpp</code>",id:"--wpp",level:3},{value:"<code>--frame-threads</code>",id:"--frame-threads",level:3},{value:"B-frames",id:"b-frames",level:2},{value:"<code>--bframes</code>",id:"--bframes",level:3},{value:"<code>--b-adapt</code>",id:"--b-adapt",level:3},{value:"<code>--bframe-bias</code>",id:"--bframe-bias",level:3},{value:"<code>--b-pyramid</code>",id:"--b-pyramid",level:3},{value:"Restoration Filtering",id:"restoration-filtering",level:2},{value:"<code>--sao</code>, <code>--limit-sao</code> and <code>--no-sao</code>",id:"--sao---limit-sao-and---no-sao",level:3},{value:"<code>--deblock</code>",id:"--deblock",level:3},{value:"Psycho-visual options",id:"psycho-visual-options",level:2},{value:"<code>--psy-rd</code> and <code>--psy-rdoq</code>",id:"--psy-rd-and---psy-rdoq",level:3},{value:"<code>--aq-mode</code> and <code>--aq-strength</code>",id:"--aq-mode-and---aq-strength",level:3},{value:"CU-Tree",id:"cu-tree",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"x265",children:"x265"})}),"\n",(0,n.jsxs)(t.p,{children:["x265 is a software library and command line application for encoding ",(0,n.jsx)(t.a,{href:"/docs/video/HEVC",children:"H.265 / HEVC"})," developed by MulticoreWare, written in C++ and x86 assembly, and released in 2013."]}),"\n",(0,n.jsx)(t.p,{children:"By default, x265 is tuned for low-bitrate content due to the blurring filters it applies, but it can be tuned for high fidelity as well and excels at it."}),"\n",(0,n.jsx)(t.p,{children:"x265 is currently not recommended for lossless encoding. For that niche, x264 is considerably faster without meaningful efficiency loss."}),"\n",(0,n.jsx)(t.h1,{id:"ffmpeg",children:"FFmpeg"}),"\n",(0,n.jsxs)(t.p,{children:["x265 is available in FFmpeg via ",(0,n.jsx)(t.code,{children:"libx265"}),", to check if you have it, run ",(0,n.jsx)(t.code,{children:"ffmpeg -h encoder=libx265"}),"."]}),"\n",(0,n.jsx)(t.h1,{id:"installation",children:"Installation"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Pre-built binary (Recommended):"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"http://msystem.waw.pl/x265/",children:"http://msystem.waw.pl/x265/"})}),"\n"]}),"\n",(0,n.jsx)(t.h1,{id:"parameters",children:"Parameters"}),"\n",(0,n.jsxs)(t.p,{children:["This section will overview the most important parameters for controlling output and quality in x265. The parameters will be listed in the format used by the standalone x265 binary,\nbut all the parameters should also be usable in FFmpeg in the format e.g. ",(0,n.jsx)(t.code,{children:"-x265-params pass=1"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"preset",children:"Preset"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.code,{children:"--preset"})}),"\n",(0,n.jsx)(t.p,{children:"In x265, we have a preset system to easily control how much effort and therefore time x265 puts into compressing video. This system possesses the following presets:"}),"\n",(0,n.jsx)(t.p,{children:"ultrafast, superfast, faster, fast, medium (default), slow, slower, veryslow and placebo"}),"\n",(0,n.jsx)(t.p,{children:"Generally speaking the further left of medium the preset is, the faster and therefore less efficient the encode is, and the opposite is true for the right side."}),"\n",(0,n.jsx)(t.p,{children:"It is recommended to pick the slowest preset you can bear to use on your hardware before messing with any of the following settings on this page, as this will be your baseline for encoder performance."}),"\n",(0,n.jsx)(t.p,{children:"It is not recommended to use the two extremes as ultrafast is terrible in its consistency and you would be better off using something like x264. placebo on the other hand performs slightly worse than\nveryslow for reasons that will be explained later."}),"\n",(0,n.jsx)(t.h2,{id:"rate-control",children:"Rate Control"}),"\n",(0,n.jsx)(t.h3,{id:"--crf",children:(0,n.jsx)(t.code,{children:"--CRF"})}),"\n",(0,n.jsx)(t.p,{children:"CRF or Constant Rate Factor is the closest thing in x265 to a quality slider for the final encode where a smaller value is higher quality and a larger value is lower quality.\nWhile CRF offers a good overall consistency, the exact quality you get at a specific CRF does still vary by source, although not as much as other methods. Changing specific settings (like psy-rd)\nor the preset you're using can change the quality at a given CRF. Usually the slower the preset, the higher the quality given a CRF."}),"\n",(0,n.jsx)(t.p,{children:"Below is a list of rough CRF values to experiment with when targeting a specific quality. This is only rough as it is source and settings dependant as explained earlier."}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Quality"}),(0,n.jsx)(t.th,{children:"720"}),(0,n.jsx)(t.th,{children:"1080"}),(0,n.jsx)(t.th,{children:"4k"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Transparent"}),(0,n.jsx)(t.td,{children:"14"}),(0,n.jsx)(t.td,{children:"16"}),(0,n.jsx)(t.td,{children:"18"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"High Quality"}),(0,n.jsx)(t.td,{children:"18"}),(0,n.jsx)(t.td,{children:"22"}),(0,n.jsx)(t.td,{children:"24"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Medium Quality"}),(0,n.jsx)(t.td,{children:"24"}),(0,n.jsx)(t.td,{children:"26"}),(0,n.jsx)(t.td,{children:"28"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Low Quality"}),(0,n.jsx)(t.td,{children:"28"}),(0,n.jsx)(t.td,{children:"30"}),(0,n.jsx)(t.td,{children:"32"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"While not always consistent, x265 aims for an increase of 6 CRF or a decrease of 6 CRF to be a half or doubling of file size, respectively."}),"\n",(0,n.jsx)(t.p,{children:"CRF is also preferable to other rate control methods due to its consistency in quality and being the most efficient mode of them all."}),"\n",(0,n.jsx)(t.h3,{id:"--bitrate",children:(0,n.jsx)(t.code,{children:"--bitrate"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--bitrate"})," as the name implies, is used to specify the target ABR for 1-pass encoding or target bitrate for VBR in 2-pass+."]}),"\n",(0,n.jsx)(t.p,{children:"It is highly discouraged to use this rate control unless required, as it is less efficient than CRF and does not keep a consistent quality like CRF either."}),"\n",(0,n.jsx)(t.h2,{id:"threading",children:"Threading"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--wpp"})," and ",(0,n.jsx)(t.code,{children:"--frame-threads"})]}),"\n",(0,n.jsx)(t.p,{children:"x265 possesses several threading features that each come with their own upsides and downsides when used."}),"\n",(0,n.jsx)(t.h3,{id:"--wpp",children:(0,n.jsx)(t.code,{children:"--wpp"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--wpp"})," or Wavefront Parallel Processing is the default method x265 uses to parallelize encoding first and foremost. With only an efficiency hit of 1-3% of the final encode, it increases threading of x265\nby 3-5x. Unless you're using a tool like Av1an for maximum efficiency encoding, it is always recommended to have this setting on (default)."]}),"\n",(0,n.jsx)(t.p,{children:"WPP works by splitting the video frame up into rows where the row is 2 CU, or super blocks in libvpx terms, behind the row above it. This allows the encoder to reference everything allowed by the\nH.265 specification. Due to it not being single threaded, some optimizations cannot be done, resulting in a small efficiency loss."}),"\n",(0,n.jsx)(t.h3,{id:"--frame-threads",children:(0,n.jsx)(t.code,{children:"--frame-threads"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--frame-threads"})," is an extension of the idea of wpp across multiple frames being encoded concurrently. Similarly, this results in a further 1-3% efficiency loss, however it can boost threading 5-7x on top of wpp."]}),"\n",(0,n.jsx)(t.p,{children:"According to reports by some users in older versions of x265, the larger the number of frame threads, the worse the efficiency impact. However, in the latest version of x265 4.1, there is no difference\nbetween 2 frame threads and the max 16 threads."}),"\n",(0,n.jsx)(t.h2,{id:"b-frames",children:"B-frames"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--bframes"}),", ",(0,n.jsx)(t.code,{children:"--b-adapt"}),", ",(0,n.jsx)(t.code,{children:"--bframe-bias"})," and ",(0,n.jsx)(t.code,{children:"--b-pyramid"})]}),"\n",(0,n.jsx)(t.p,{children:"B-frames are bi-directional predictive frames. This means they can reference either past, future or both types of frames at the same time, making them one of the most efficient types. B-frames\nhowever are usually the most compressed frame types. Referencing other frames rather than storing their own detail (typically) makes them often the worse quality and blurry frames. In total, we\nhave 4 different settings to control how they are used by the encoder. Usually, you will never touch these."}),"\n",(0,n.jsx)(t.h3,{id:"--bframes",children:(0,n.jsx)(t.code,{children:"--bframes"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--bframes"})," is used to control the max number of consecutive B-frames the encoder is allowed to use and search for. Generally, the larger this value is to a max of ",(0,n.jsx)(t.code,{children:"16"})," the slower but more\nefficient the encoder becomes. However, in higher fidelity encodes around CRF 18 or lower, beyond 8-12 B-frames can start to hurt detail for the reasons stated above. Likewise, the benefits of\nmore B-frames vs the time it takes makes it not typically worth it beyond a similar point."]}),"\n",(0,n.jsx)(t.p,{children:"In general, it is best to leave this setting at the default for your preset. However, for content like anime or otherwise flat non IRL, adding +2 B-frames to the current preset generally gives a\nsmall efficiency boost. You can also set it to the max value of 16 for micro encodes to try and squeeze the most efficient possible out of the encoder, if time is no object to you."}),"\n",(0,n.jsx)(t.h3,{id:"--b-adapt",children:(0,n.jsx)(t.code,{children:"--b-adapt"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--b-adapt"})," controls the method that the encoder uses to decide where to put B-frames. It has 3 different modes."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"mode"}),(0,n.jsx)(t.th,{children:"feature"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"1"}),(0,n.jsx)(t.td,{children:"Fixed"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"2"}),(0,n.jsx)(t.td,{children:"Light lookahead"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"3"}),(0,n.jsx)(t.td,{children:"Viterbi trellis (default)"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"It is always recommended to use 3 as it comes at a negligible speed penalty and is the smartest at placing B-frames for maximum efficiency without harming visual fidelity."}),"\n",(0,n.jsx)(t.h3,{id:"--bframe-bias",children:(0,n.jsx)(t.code,{children:"--bframe-bias"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--bframe-bias"})," as the name implies, is used to control the bias for x265 to use B-frames over other frame types. Normally,you should never touch this setting as the default of ",(0,n.jsx)(t.code,{children:"0"})," is already\noptimal for most cases, however for high fidelity encodes or micro encodes, adjusting this bias can help retain detail or sacrifice spacial detail for better temporal information."]}),"\n",(0,n.jsx)(t.h3,{id:"--b-pyramid",children:(0,n.jsx)(t.code,{children:"--b-pyramid"})}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--b-pyramid"})," or ",(0,n.jsx)(t.code,{children:"--no-b-pyramid"})," decides if B-frames can be used as reference frames for other B-frames or other frame types. Normally, this should always be on and is the default. However, for\nhigh fidelity encodes, it might be worthwhile experimenting with turning it off only in limited use cases."]}),"\n",(0,n.jsx)(t.h2,{id:"restoration-filtering",children:"Restoration Filtering"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--sao"}),", ",(0,n.jsx)(t.code,{children:"--limit-sao"}),", ",(0,n.jsx)(t.code,{children:"--no-sao"})," and ",(0,n.jsx)(t.code,{children:"--deblock"})]}),"\n",(0,n.jsxs)(t.h3,{id:"--sao---limit-sao-and---no-sao",children:[(0,n.jsx)(t.code,{children:"--sao"}),", ",(0,n.jsx)(t.code,{children:"--limit-sao"})," and ",(0,n.jsx)(t.code,{children:"--no-sao"})]}),"\n",(0,n.jsx)(t.p,{children:"SAO or Sample Adaptive Offset is a restoration filter in H.265 used to prevent obvious blocking and ringing artifacts, especially around sharp edges.\nHowever, this does sometimes come at the cost of some finer details in the video, like for example human skin and surface details, to be erased.\nGenerally speaking, at CRF values at or above 20, you can leave this option on, which is default as it does a good job of making the overall video more appealing."}),"\n",(0,n.jsxs)(t.p,{children:['x265 however has a primitive implementation of SAO which tends to be too aggressive at high quality or fidelity ranges, leading to blurring around CRF 19-16.\nWhile it does "limit" how much the encoder uses SAO, ',(0,n.jsx)(t.code,{children:"--limit-sao"})," is more of an early termination for the encoder deciding where to use it rather than limiting its strength.\nHowever, it generally does a good job of preserving more detail than normal, even if it makes some artifacts more noticeable."]}),"\n",(0,n.jsxs)(t.p,{children:["For below CRF 16, depending on your content, it might be preferable to outright disable sao with ",(0,n.jsx)(t.code,{children:"--no-sao"}),", as usually at such high quality it's not usually needed."]}),"\n",(0,n.jsx)(t.h3,{id:"--deblock",children:(0,n.jsx)(t.code,{children:"--deblock"})}),"\n",(0,n.jsx)(t.p,{children:"Word of caution, the documentation around the deblock setting is esoteric."}),"\n",(0,n.jsxs)(t.p,{children:["Deblock is another loop filter, this one intended to reduce blocking in videos, but may have a blurring effect at high strengths. For most encodes, it is fine to leave this\nat the default value. At lower CRF values, it may be desirable to lower this to ",(0,n.jsx)(t.code,{children:"--deblock -1:-1"})," for anime or ",(0,n.jsx)(t.code,{children:"--deblock -2:-2"})," for live action, in order to preserve\nmore grain and detail."]}),"\n",(0,n.jsx)(t.h2,{id:"psycho-visual-options",children:"Psycho-visual options"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--psy-rd"}),", ",(0,n.jsx)(t.code,{children:"--psy-rdoq"}),", ",(0,n.jsx)(t.code,{children:"--aq-mode"})," and ",(0,n.jsx)(t.code,{children:"--aq-strength"})]}),"\n",(0,n.jsxs)(t.p,{children:["You can read more about the importance of perceptual optimization in video encoders on the ",(0,n.jsx)(t.a,{href:"/docs/introduction/psychovisual",children:"psychovisual"})," page."]}),"\n",(0,n.jsxs)(t.h3,{id:"--psy-rd-and---psy-rdoq",children:[(0,n.jsx)(t.code,{children:"--psy-rd"})," and ",(0,n.jsx)(t.code,{children:"--psy-rdoq"})]}),"\n",(0,n.jsxs)(t.p,{children:["To make a long story short, ",(0,n.jsx)(t.code,{children:"--psy-rd"})," and ",(0,n.jsx)(t.code,{children:"--psy-rdoq"})," together are psychovisual optimization tools used to control the encoder's willingness to retain finer detail and noise in the\nfinal encode. However, the way the two settings achieve this are very different."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--psy-rd"}),' retains detail by affecting how the encoder weights sections of the frame based off the amount of "energy" or high frequency information it contains and boosts them\naccordingly.']}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--psy-rdoq"})," retains detail by affecting how the encoder quantizes coefficients after transformations. It has no reference to the source in its calculation and only prefers retaining overall visual\nenergy and nothing specific."]}),"\n",(0,n.jsxs)(t.p,{children:["Both settings are highly source dependent and ideally would be tweaked per scene in a video. Unless you know what you're doing and are willing to test thoroughly that the settings you\nare using are beneficial, it's almost always recommended to never touch either setting, as the defaults for both are good general purpose settings.\nHowever, as a general rule of thumb, ",(0,n.jsx)(t.code,{children:"--psy-rd"})," is better at retaining specific detail and overall sharpness while ",(0,n.jsx)(t.code,{children:"--psy-rdoq"})," is better at retaining overall noise."]}),"\n",(0,n.jsxs)(t.h3,{id:"--aq-mode-and---aq-strength",children:[(0,n.jsx)(t.code,{children:"--aq-mode"})," and ",(0,n.jsx)(t.code,{children:"--aq-strength"})]}),"\n",(0,n.jsxs)(t.p,{children:["Adaptive quantization (",(0,n.jsx)(t.code,{children:"--aq-mode"}),"), shortened to AQ, is a mechanism to redistribute bitrate within a frame to improve perceptual quality consistency.\nIn x265, we have 4 modes."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"mode"}),(0,n.jsx)(t.th,{children:"feature"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"1"}),(0,n.jsx)(t.td,{children:"AQ enabled"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"2"}),(0,n.jsx)(t.td,{children:"AQ with auto variance (default)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"3"}),(0,n.jsx)(t.td,{children:"AQ 2 with a bias for dark scenes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"4"}),(0,n.jsx)(t.td,{children:"AQ 2 with edge information"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"Generally speaking, we always want AQ 2 or AQ with auto variance as this will bias both parts of the frame that are smooth and textured. Normally, these parts of the frame are bitrate starved\nand have the most noticeable artifacting."}),"\n",(0,n.jsx)(t.p,{children:"Some people will use AQ 3 to, as the name implies, preserve detail in dark scenes and parts of the frame. However, in metric analysis and visual comparisons, AQ 3 can sometimes bloat bitrates for minor to\nno gains. While this is not an entirely useless AQ mode, thorough testing should be done before using it."}),"\n",(0,n.jsxs)(t.p,{children:["The relative strength of an AQ mode can also be controlled with ",(0,n.jsx)(t.code,{children:"--aq-strength"}),". While the default is ",(0,n.jsx)(t.code,{children:"1.0"}),", many people do lower it to ",(0,n.jsx)(t.code,{children:"0.7"})," or ",(0,n.jsx)(t.code,{children:"0.8"})," for flat anime or compressed IRL content.\nIn general, like other psychovisual optimization tools in x265, these settings are highly source dependant and are best left at their defaults, unless you know what you are doing and have data\nto back it up."]}),"\n",(0,n.jsx)(t.h2,{id:"cu-tree",children:"CU-Tree"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"--cutree"})," and ",(0,n.jsx)(t.code,{children:"--no-cutree"})]}),"\n",(0,n.jsx)(t.p,{children:"CU-Tree similar to MB-Tree in x264 is a method for the encoder to keep track of what parts of the frame are used or referenced by future frames. In a sense, it's a temporal motion quantizer.\nIt has been very common for a long time, all the way back when only x264 existed, for people to disable MB-Tree due to the idea that it removed too much detail or blurred the video.\nHowever, a lot of that blur and detail loss would occur in parts of the frame that viewers would not be able to see clearly due to motion, or in areas that didn't significantly\ncontribute to the overall image quality during playback. Both MB-Tree and CU-tree have also gotten a lot better since their original implementation making it almost\nalways worse to disable them rather than to keep them enabled."}),"\n",(0,n.jsx)(t.p,{children:"Anyone telling you to disable either must provide evidence of it being actually better."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>a});var s=i(6540);const n={},r=s.createContext(n);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);