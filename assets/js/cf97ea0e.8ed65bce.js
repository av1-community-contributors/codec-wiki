"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[7547],{310:e=>{e.exports=JSON.parse('{"permalink":"/blog/turbo-metrics-performance","source":"@site/blog/2024-11-21-turbo-metrics-evaluation.mdx","title":"Fast Computation of SSIMULACRA2 on GPUs: A Performance Evaluation","description":"Turbo-metrics offers GPU acceleration for popular video quality metrics. Let\'s put it to the test!","date":"2024-11-21T00:00:00.000Z","tags":[{"inline":true,"label":"video","permalink":"/blog/tags/video"},{"inline":true,"label":"metrics","permalink":"/blog/tags/metrics"},{"inline":true,"label":"benchmarks","permalink":"/blog/tags/benchmarks"}],"readingTime":23.68,"hasTruncateMarker":true,"authors":[{"name":"Bolu","title":"Novice Encoder / Programmer","url":"https://github.com/0xb01u/","image_url":"https://avatars.githubusercontent.com/u/4998967","imageURL":"https://avatars.githubusercontent.com/u/4998967","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Fast Computation of SSIMULACRA2 on GPUs: A Performance Evaluation","description":"Turbo-metrics offers GPU acceleration for popular video quality metrics. Let\'s put it to the test!","slug":"turbo-metrics-performance","authors":[{"name":"Bolu","title":"Novice Encoder / Programmer","url":"https://github.com/0xb01u/","image_url":"https://avatars.githubusercontent.com/u/4998967","imageURL":"https://avatars.githubusercontent.com/u/4998967"}],"tags":["video","metrics","benchmarks"],"image":"/img/blog_turbo-metrics_11-2024/image.avif","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Deep Dive into SVT-AV1\'s Evolution (Part 1): Presets Analysis from v2.0 to v3.0","permalink":"/blog/svt-av1-fourth-deep-dive-p1"},"nextItem":{"title":"Better late than never: SVT-AV1 v2.2.x Deep Dive","permalink":"/blog/svt-av1-third-deep-dive"}}')},713:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var i=s(310),n=s(4848),r=s(8453);const o={title:"Fast Computation of SSIMULACRA2 on GPUs: A Performance Evaluation",description:"Turbo-metrics offers GPU acceleration for popular video quality metrics. Let's put it to the test!",slug:"turbo-metrics-performance",authors:[{name:"Bolu",title:"Novice Encoder / Programmer",url:"https://github.com/0xb01u/",image_url:"https://avatars.githubusercontent.com/u/4998967"}],tags:["video","metrics","benchmarks"],image:"/img/blog_turbo-metrics_11-2024/image.avif",hide_table_of_contents:!1},a="Introduction",l={authorsImageUrls:[void 0]},c=[{value:"Basics",id:"basics",level:2},{value:"SSIMULACRA2",id:"ssimulacra2",level:3},{value:"In-depth: SSIMULACRA2 computation",id:"in-depth-ssimulacra2-computation",level:4},{value:"SSIMULACRA2 subsampling",id:"ssimulacra2-subsampling",level:4},{value:"TurboMetrics",id:"turbometrics",level:3},{value:"In-depth: Implementation differences from the reference",id:"in-depth-implementation-differences-from-the-reference",level:4},{value:"Performance evaluation",id:"performance-evaluation",level:2},{value:"Setup",id:"setup",level:3},{value:"Results and discussion",id:"results-and-discussion",level:3},{value:"Considerations about video decoding performance",id:"considerations-about-video-decoding-performance",level:3},{value:"Conclusions",id:"conclusions",level:3},{value:"Further discussion: Possible improvements",id:"further-discussion-possible-improvements",level:3},{value:"Short discussion on scoring error",id:"short-discussion-on-scoring-error",level:2},{value:"Overall conclusions and final thoughts",id:"overall-conclusions-and-final-thoughts",level:2},{value:"Future",id:"future",level:2},{value:"Special thanks",id:"special-thanks",level:4}];function d(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["In this blog entry, we will evaluate the performance of ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics",children:"TurboMetrics"}),", a software which provides a GPU-accelerated implementation of SSIMULACRA2, and promises to save a lot of time in its computation."]}),"\n",(0,n.jsxs)(t.p,{children:["Video encoding is a time-consuming task by itself. When it comes to assessing the resulting encodes, objective quality metrics are often used, providing advantages over subjective measurements, e.g., faster evaluation processes. Nevertheless, the computation of some of these metrics is still somewhat slow. This is the case for ",(0,n.jsx)(t.a,{href:"https://wiki.x266.mov/docs/metrics/SSIMULACRA2",children:"SSIMULACRA2"}),", one of the most popular objective metrics for image and video assessment."]}),"\n",(0,n.jsx)(t.h2,{id:"basics",children:"Basics"}),"\n",(0,n.jsx)(t.p,{children:"Before we start with the evaluation, we will first cover some fundamental (and not-so-fundamental) concepts."}),"\n",(0,n.jsx)(t.h3,{id:"ssimulacra2",children:"SSIMULACRA2"}),"\n",(0,n.jsxs)(t.p,{children:['SSIMULACRA2, which is sometimes abbreviated as "ssimu2", is a perceptual metric for images, based on the concept of the multi-scale structural similarity index measure (',(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Structural_similarity_index_measure",children:"MS-SSIM"}),'). In the words of its developer, it is "[based on MS-SSIM], computed in a perceptually relevant color space, adding two other (asymmetric) error maps, and aggregating using two different norms". A total of 54 error maps are computed over multiple downscalings (from 1:1 to 1:32) of the image to assess (',(0,n.jsx)(t.em,{children:"distorted"}),") and its source image (",(0,n.jsx)(t.em,{children:"reference"}),"). These error maps are then added using a weighted sum to produce the final SSIMULACRA2 score. The weight of each error map is tuned based on a large set of subjective scores from different image benchmarks."]}),"\n",(0,n.jsx)(t.p,{children:"SSIMULACRA2 scores are in the range [-inf, 100]. They are reported to correlate to subjective visual quality scores as follows:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"30 = low quality"}),"\n",(0,n.jsx)(t.li,{children:"50 = medium quality"}),"\n",(0,n.jsx)(t.li,{children:"70 = high quality"}),"\n",(0,n.jsx)(t.li,{children:"90 = very high quality; likely impossible to distinguish from the original when viewed at 1:1 from a normal viewing distance"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'One special consideration when using SSIMULACRA2 to assess video quality is that, even though the developers state that a score of 90 corresponds to a "visually lossless" image, for videos, this threshold is considered to be lower, around 80. This is because it is harder to notice artifacts on individual frames, given the short period of time the viewer perceives them (usually, between 1/24 and 1/60 of a second, 0.04167 and 0.0167 seconds, respectively).'}),"\n",(0,n.jsxs)(t.p,{children:["The reference implementation for SSIMULACRA2 can be found ",(0,n.jsx)(t.a,{href:"https://github.com/cloudinary/ssimulacra2",children:"here"}),". Other popular implementations include ",(0,n.jsx)(t.a,{href:"https://docs.rs/crate/ssimulacra2_rs/latest",children:"the Rust implementation"}),", and ",(0,n.jsx)(t.a,{href:"https://github.com/dnjulek/vapoursynth-zip",children:"the Zig implementation"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["Although technically speaking SSIMULACRA2 is an image-focused metric, it has gained popularity as a video assessment metric due to its reliability in correlating to subjective measurements. It is considered to provide better results than other historically more popular metrics, such as ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio",children:"PSNR"}),", ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Structural_similarity_index_measure",children:"(MS-)SSIM"}),", and even ",(0,n.jsx)(t.a,{href:"https://github.com/Netflix/vmaf",children:"VMAF"}),". In that context, each video frame is treated as a separate image. SSIMULACRA2 scores are computed for each of the video's frames independently, and the average is taken as the video's score. Other useful statistics include the standard deviation (which correlates to the consistency of the quality of the video), the median, the 5th percentile, and the 95th percentile. Although SSIMULACRA2 is considered to be quite reliable for video assessment, it is worth noting that, being a purely image-based metric, it disregards any temporal information present in videos, which might be seen as a disadvantage. Other metrics, such as ",(0,n.jsx)(t.a,{href:"https://github.com/fraunhoferhhi/xpsnr",children:"XPSNR"}),", were developed with video assessment as their main objective, and do consider temporal information."]}),"\n",(0,n.jsx)(t.p,{children:"As stated previously, SSIMULACRA2 computes 54 error maps per image assessed. This entails a high amount of computation, especially for videos, which usually contain tens of thousands of frames (images). That explains its rather slow execution time. Speeding up these computations would be very much desired, if possible."}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h4,{id:"in-depth-ssimulacra2-computation",children:"In-depth: SSIMULACRA2 computation"}),"\n",(0,n.jsxs)(t.p,{children:["The summary of the algorithm for SSIMULACRA2 is the following, as ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics/blob/master/crates/ssimulacra2-cuda/README.md#computing-ssimulacra2",children:"reported here"}),":"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Get the frame pair (reference and distorted)."}),"\n",(0,n.jsx)(t.li,{children:"Convert the frames to linear RGB (using 32-bit floating-point)."}),"\n",(0,n.jsxs)(t.li,{children:["For each scale (1:1 to 1:32, downsampling by 2 every step: 6 different scales):","\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Downscale by the scale number (if needed)."}),"\n",(0,n.jsx)(t.li,{children:"Convert the frames to XYB color space."}),"\n",(0,n.jsx)(t.li,{children:"Blur the following pictures, using a recursive Gaussian blur: (reference * reference), (distorted * distorted), (reference * distorted), (reference), (distorted)."}),"\n",(0,n.jsx)(t.li,{children:"Compute 1-SSIM, artifact and detail_loss error scores from the 5 blurred images and the original frame pair; this yields 3 error maps."}),"\n",(0,n.jsx)(t.li,{children:"The error maps are reduced to a single number using the 1-norm and 4-norm."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.li,{children:"From this, we get 6 scores for each scale (6) and color component (3), totaling 108 scores."}),"\n",(0,n.jsx)(t.li,{children:"The scores are added using a weighted sum."}),"\n",(0,n.jsx)(t.li,{children:"The final value is processed through a non-linear function and clipped to render a score between 100 and -infinite."}),"\n"]}),"\n",(0,n.jsx)(t.h4,{id:"ssimulacra2-subsampling",children:"SSIMULACRA2 subsampling"}),"\n",(0,n.jsxs)(t.p,{children:["Given that the metric is quite slow to compute, it is often computed over a subset (subsample) of the video frames, instead of over all of them. For example, a ",(0,n.jsx)(t.em,{children:"stride"})," of 3 could be used, to compute SSIMULACRA2 scores for 1 frame out of every 3 in the video, skipping the computation for the other 2 frames. This is expected to speedup the computation by a factor of \xd73."]}),"\n",(0,n.jsxs)(t.p,{children:["However, this evidently induces an ",(0,n.jsx)(t.em,{children:"error"}),' in the score, as the average of the scores of a subsample of the video frames is not guaranteed to be equal to the average of the scores of all the frames. The smaller the subsample (i.e., the higher the computation stride), the higher this error will be. Nevertheless, it has been reported that small strides usually produce averages significantly close to the real average of all the frames. Thus, it is pretty safe to do this. To minimize the error of this sampling method, it has been stated that "as long as you don\'t sample in a power of two ([i.e., every] 2, 4, 8... [frames]), you\'ll be fine, as you want to pick frames from every temporal layer [of the video]". Other sources further recommend picking strides that are prime numbers (e.g., 1 every 3, 5, 7, 11... frames), since "prime numbers reduce the likelihood of sampling bias due to constant frame rate".']}),"\n",(0,n.jsx)(t.h3,{id:"turbometrics",children:"TurboMetrics"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics",children:"TurboMetrics"})," is a WIP software suite developed by the very talented ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom",children:"Gui-Yom/LimelioN"}),'. It is "a collection of video related libraries and tools oriented at performance and hardware acceleration". It comes as a collection of Rust libraries/crates, and some include command-line applications to interact with them. There are currently no public releases of the suite in the dedicated "Releases" page of its GitHub repository, but you can download the code and compile it yourself. The latest tagged version of the software, at the moment of writing, is v0.2.2.']}),"\n",(0,n.jsxs)(t.p,{children:["TurboMetrics focuses mainly on ",(0,n.jsx)(t.strong,{children:"NVIDIA GPUs"})," using CUDA. However, the developer is actively working on adding support for other hardware (e.g., AMD and Intel GPUs). Nevertheless, I only have experience with NVIDIA GPUs, so I cannot tell how the progress is going on that front."]}),"\n",(0,n.jsx)(t.p,{children:"Among the tools, there is a working SSIMULACRA2 implementation that uses CUDA to leverage GPU acceleration, ssimulacra2-cuda. We will focus exclusively on it from now on. We will use this tool to compute SSIMULACRA2 scores for certain video samples. However, it is worth noting that the tool is also able to compute other metrics, such as SSIM and PSNR. It can even compute multiple metrics on the same rum."}),"\n",(0,n.jsxs)(t.p,{children:["ssimulacra2-cuda is ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics/tree/master/crates/ssimulacra2-cuda",children:"stated to be"}),' "close to the original implementation, and with close results". Also, the developer has said that "[r]ight now, [it] can compute SSIMULACRA2 orders of magnitude faster than the ssimulacra2_rs implementation". Therefore, we can expect the tool to compute SSIMULACRA2 scores for videos much faster than any CPU implementation out there, but provide scores that are not quite the same as the ones those CPU implementations would give, including the reference one. In this blog entry, we will test that second claim, concerning the speed of TurboMetrics in computing SSIMULACRA2.']}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h4,{id:"in-depth-implementation-differences-from-the-reference",children:"In-depth: Implementation differences from the reference"}),"\n",(0,n.jsxs)(t.p,{children:["As ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics/blob/master/crates/ssimulacra2-cuda/README.md#differences-from-the-reference-implementation",children:"reported here"}),", the GPU implementation of SSIMULACRA2 provided in TurboMetrics differs from the reference implementation in the following ways that can affect the accuracy of the reported scores:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The conversion from YUV to linear RGB might not be yielding the same results as other tools."}),"\n",(0,n.jsx)(t.li,{children:"Explicit Fused Multiply-Add (FMA) operations are used when possible, as the GPU can leverage them for higher performance."}),"\n",(0,n.jsx)(t.li,{children:"The order of operations might not be the same, as some calculations have been rearranged."}),"\n",(0,n.jsxs)(t.li,{children:["Floating-point operations might not yield the same results, especially with the approximated math functions used in the GPU (like ",(0,n.jsx)(t.code,{children:"powf"}),")."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Additionally, the differences in scores are amplified by the following features of the SSIMULACRA2 computation:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The original weights were computed by fitting the error scores to Mean Opinion Score (MOS), and deviation in the error scores is amplified by them."}),"\n",(0,n.jsx)(t.li,{children:"The final non-linear function is rather steep (it is a cubic function, x\xb3), and, thus, score variations are amplified again."}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"performance-evaluation",children:"Performance evaluation"}),"\n",(0,n.jsx)(t.h3,{id:"setup",children:"Setup"}),"\n",(0,n.jsx)(t.p,{children:"In this experiment, we will evaluate TurboMetrics in terms of performance; that is, the amount of ssimu2 scores computed per unit of time. For that, an episode of an animated series (~25 minutes), encoded with H.264, has been chosen as sample video. However, the kind of video content used, and most of its technical characteristics (e.g., codec, encoding parameters, etc.) except for resolution, should be irrelevant, as the same computations are performed for every video of specific frame dimensions. In this case, the video has a resolution of 1080p (1920\xd71080 pixels per frame), with 8 bits per pixel, and YUV color space with 4:2:0 chroma subsampling."}),"\n",(0,n.jsxs)(t.p,{children:["The video source and example distorted encode have been compared using ",(0,n.jsx)(t.strong,{children:"ssimulacra2_rs"}),", ",(0,n.jsx)(t.strong,{children:"vszip"}),", and ",(0,n.jsx)(t.strong,{children:"TurboMetrics"}),". ssimulacra2_rs and vszip are both CPU implementations of SSIMULACRA2, the former written in Rust and the latter in Zig (but invoked from VapourSynth/Python scripts). It has been reported that the Zig implementation is considerably faster than the Rust one, and we can check that out as well!"]}),"\n",(0,n.jsxs)(t.p,{children:["The CPU implementations have been executed on an Intel i5-11400 CPU (base frequency of 2.60 GHz, turbo frequency of 4.40 GHz), using 6 CPU cores (",(0,n.jsx)(t.code,{children:"-f 6"})," parameter in ssimulacra2_rs, ",(0,n.jsx)(t.code,{children:"-t 6"})," parameter in ssimulacravszip.py). TurboMetrics has been executed both on an NVIDIA GTX 1060 GPU and an NVIDIA RTX 4060 GPU. The three programs have been executed for the same video pair with ",(0,n.jsx)(t.strong,{children:"varying frame strides: 1, 3, 5, 7, 11, 13, 17, 19, and 23"})," (not skipping frames, plus every prime number lower than 24 frames / 1 second, excluding 2)."]}),"\n",(0,n.jsx)(t.p,{children:"For the CPU and RTX 4060 executions, the distorted video was a custom AV1 encode of the reference video. For the GTX 1060, as it does not have AV1 decoding hardware support, the H.264 reference video was compared to itself (the computations being performed should be equivalent anyway)."}),"\n",(0,n.jsx)(t.h3,{id:"results-and-discussion",children:"Results and discussion"}),"\n",(0,n.jsx)(t.p,{children:"The exact results of this experiment are shown in the following table:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Stride"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"ssimulacra2_rs FPS"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"vszip FPS"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"GTX 1060 GPU FPS"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"RTX 4060 GPU FPS"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"1"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3.37"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"14.63"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"46.70"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"85.64"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"9.55"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"37.67"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"133.86"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"245.73"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"5"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"15.15"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"49.34"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"164.34"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"350.01"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"7"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"20.45"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"56.37"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"197.17"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"400.94"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"11"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"30.23"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"64.46"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"222.98"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"458.61"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"13"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"34.54"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"66.65"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"239.17"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"488.83"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"17"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"40.51"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"69.23"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"249.58"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"520.30"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"19"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"42.82"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"69.99"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"258.71"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"525.44"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"23"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"45.43"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"88.60"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"264.85"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"546.14"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"Here they are in graph form, for better visualization:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"CPU vs GPUs decoded FPS",src:s(4892).A+"",width:"614",height:"461"})}),"\n",(0,n.jsx)(t.p,{children:"On a superficial level, we can already make some observations:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["SSIMULACRA2 computation with ssimulacra2_rs is quite slow: 3.37 frames per second (without skipping frames) when using 6 threads. That is like 0.56 frames per second per thread. I know the CPU used is no beast by any measure, but beast CPUs are quite expensive and not that common (that is something to keep in mind). Those processing speeds are comparable to some of the slower-ish presets of SVT-AV1.","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"vszip is, in fact, considerably faster: Between \xd74.34 (full video computation) and \xd71.63 (stride of 19) with the same amount of threads. However, it seems that vszip does not scale as well as the other implementations (except for that weird performance boost with a stride of 23)."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["GPU computation of SSIMULACRA2 scores is impressive, considering the CPU performances:","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Compared to ssimulacra2_rs: Speedups for the GTX 1060 (an 8-year-old GPU) are between \xd714.01 (stride of 3) and \xd75.83 (stride of 23). Speedups for the RTX 4060 are between \xd725.73 (stride of 3) and \xd712.02 (stride of 23)."}),"\n",(0,n.jsx)(t.li,{children:"Compared to vszip: Speedups for the GTX 1060 are between \xd73.70 (stride of 19) and \xd72.99 (stride of 23). Speedups for the RTX 4060 are between \xd77.51 (stride of 17) and \xd75.85 (stride of 1 / full video computation)."}),"\n",(0,n.jsx)(t.li,{children:"It is amazing seeing how GPUs not only achieve real-time SSIMULACRA2 computation of entire videos, but more than \xd71.94 and \xd73.56 real-time processing, even (GTX and RTX, respectively)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Nevertheless, the most interesting observation is made when we use computation strides bigger than 1: The performance does ",(0,n.jsx)(t.em,{children:"not"})," scale linearly with the stride, as it would be expected. This happens with both the CPU and GPUs, although it is more noticeable in the case of the GPUs due to their higher performance."]}),"\n",(0,n.jsxs)(t.p,{children:["Why is that? Well, there is actually a good explanation: The reported FPS are ",(0,n.jsx)(t.em,{children:"decoded"})," FPS. That is, the speed in which the software is decoding and processing all the video frames. All the frames in the video bitstream are decoded and reconstructed as images, but the SSIMULACRA2 score is only computed for some of them. SSIMULACRA2 computation affects decoding speed in that the decoding of each frame only starts after the processing of the previous has finished (kind of, this is not be entirely true for multithreaded CPU implementations, but we can ignore that). The faster the SSIMULACRA2 processing is done, the sooner the next frame starts decoding. And there is no faster processing than not doing any processing at all, that is, skipping the frame! However, ",(0,n.jsx)(t.strong,{children:"the decoding itself is a process that has to be done regardless"}),", and the time it takes should not be disregarded. Although decoding as a process is considerably faster than SSIMULACRA2 computation, it starts becoming the bottleneck when you both compute SSIMULACRA2 so fast, and skip computing frames."]}),"\n",(0,n.jsx)(t.h3,{id:"considerations-about-video-decoding-performance",children:"Considerations about video decoding performance"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://docs.nvidia.com/video-technologies/video-codec-sdk/12.0/nvdec-application-note/index.html#nvdec-performance",children:"According to NVIDIA"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The GTX 1060 is able to decode H.264 1080p YUV 4:2:0 video at up to 696 frames per second."}),"\n",(0,n.jsx)(t.li,{children:"The RTX 4060 is able to decode H.264 1080p YUV 4:2:0 video at up to 883 frames per second."}),"\n",(0,n.jsx)(t.li,{children:"The RTX 4060 is able to decode AV1 1080p YUV 4:2:0 video at up to 1005 frames per second."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Being proprietary NVIDIA technology, served as a black box through their API, we cannot be sure how the NVDEC engines are implemented and what exactly are their limitations under scenarios such as these (i.e., concurrent decoding of multiple video streams of same or different codecs). We can only trust the information NVIDIA provides. NVIDIA states that all GeForce products consist of a single NVDEC; however, we cannot be certain how its resources are managed or shared when working with multiple simultaneous decoding contexts.\nIn our case, considering two videos are being decoded at the same time:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The GTX 1060 decodes up to 529.7 H.264 (2\xd7264.85) frames per second when using a stride of 23 frames, which corresponds to 75% of its reported peak decoding performance for H.264."}),"\n",(0,n.jsxs)(t.li,{children:["The RTX 4060 decodes up to 546.14 H.264 + 546.14 AV1 (1092.28 total) frames per second when using a stride of 23 frames, which corresponds to 61.85% and 54.34% of its reported peak decoding performance for H.264 and AV1 respectively. Notice how, even though the NVDEC hardware resources are reportedly being shared between the two decodes, both are able to reach more than 50% peak performance ",(0,n.jsx)(t.strong,{children:"at the same time"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["We can just focus on ",(0,n.jsx)(t.em,{children:"processed"})," FPS, that is, only not-skipped frames processed per second, or SSIMULACRA2 scores computed per second, to see how the processing performance degrades with increasing strides."]}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"Stride"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"ssimulacra2_rs FPS"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"vszip FPS"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"GTX 1060 GPU FPS"}),(0,n.jsx)(t.th,{style:{textAlign:"center"},children:"RTX 4060 GPU FPS"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"1"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3.37"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"14.63"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"46.70"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"85.64"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3.18"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"12.56"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"44.62"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"81.91"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"5"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3.03"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"9.87"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"32.87"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"70.00"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"7"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"2.92"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"8.05"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"28.17"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"57.28"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"11"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"2.75"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"5.86"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"20.27"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"41.69"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"13"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"2.66"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"5.13"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"18.40"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"37.60"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"17"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"2.38"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"4.07"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"14.68"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"30.61"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"19"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"2.25"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3.68"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"13.62"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"27.65"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"23"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"1.98"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"3.85"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"11.52"}),(0,n.jsx)(t.td,{style:{textAlign:"center"},children:"23.75"})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"Here they are in graph form, for better visualization:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"CPU vs GPUs processed FPS",src:s(4273).A+"",width:"614",height:"461"})}),"\n",(0,n.jsx)(t.p,{children:"It can be seen how the actual SSIMULACRA2 processing performance quickly decreases, as more and more relative time gets dedicated to decoding the videos."}),"\n",(0,n.jsxs)(t.p,{children:["One should also note that the NVDEC hardware is the same for all GPUs in the same generation (e.g., all the RTX 40 GPUs). Therefore, even if the computation of the SSIMULACRA2 scores of a video could still be accelerated further by using more powerful GPUs, e.g., RTX 4070/4080/4090, that would only be significant when using small strides. As the stride increases, the video decoding will become the bottleneck for all those GPUs sooner or later, and all of them would perform similarly to the RTX 4060. In other words: ",(0,n.jsx)(t.strong,{children:"rather than spending more money on a more powerful GPU to compute SSIMULACRA2 faster, it is much more worthwhile to just increase the stride"}),"; especially since the error incurred from using a stride greater than 1 usually is statistically almost insignificant."]}),"\n",(0,n.jsx)(t.h3,{id:"conclusions",children:"Conclusions"}),"\n",(0,n.jsx)(t.p,{children:"As a quick summary of the experiment, we can highlight:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"GPU processing greatly accelerates SSIMULACRA2 computation"}),", with modern GPUs enabling speeds ",(0,n.jsx)(t.strong,{children:"faster than real-time"})," for most 1080p content (~85 fps), including gaming; and old GPUs still providing speeds faster than real-time (~46 fps) for popular, lower-fps 1080p video, such as movies and series."]}),"\n",(0,n.jsxs)(t.li,{children:["As SSIMULACRA2 computations accelerate, ",(0,n.jsx)(t.strong,{children:"video decoding speed becomes a relevant factor, to the point of being the main bottleneck when the computation stride is large enough"}),". It is not worthwhile to increase the computation stride too much, as you will quickly get diminishing returns in performance."]}),"\n"]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h3,{id:"further-discussion-possible-improvements",children:"Further discussion: Possible improvements"}),"\n",(0,n.jsxs)(t.p,{children:["One may think that a possible solution to the decoding speed bottleneck, which does not require waiting until the next-generation GPUs implement faster decoding hardware, would be to ",(0,n.jsx)(t.strong,{children:"make the software decode only the frames that are going to be processed"}),". Nevertheless, that approach comes with significant caveats: In modern video coding, frames cannot be decoded independently of each other, and a full group-of-pictures (GOP) would need to be decoded to reconstruct any of its frames. Usually, GOPs are from 1 to 10 seconds long (24 to 240 frames in our test case), depending on the encoding settings. Using any computation stride smaller than the GOP size would not see any benefit from this technique; and greater computation strides ",(0,n.jsx)(t.strong,{children:"would only see limited benefits"}),". (Aside from the possible accuracy/representativeness concerns associated to using such big strides.) Additionally, when leveraging GPU programming, the actual hardware is often treated like a black box, and the available APIs may limit considerably the control the user has over it."]}),"\n",(0,n.jsxs)(t.p,{children:["Another, more useful approach one may think of, would be to exploit ",(0,n.jsx)(t.strong,{children:"computation overlapping"}),": To keep decoding frames while the SSIMULACRA2 scores are being computed, storing the decoded frames that are to be processed in a buffer. This seems to be partially implemented in TurboMetrics already, but only to some extent."]}),"\n",(0,n.jsx)(t.p,{children:"Without any modification to the SSIMULACRA2 computations, the overlap in computation and decoding would still have limited effect for low strides (where SSIMULACRA2 computation is still the bottleneck), as every time the decoded frame buffer fills completely, the decoder would have to wait for it to have free space again. In theory, the SSIMULACRA2 computations could be sped up further (maybe requiring faster but more imprecise approximations). And, ideally, TurboMetrics should aim to approach the theoretical decode FPS limit in the computation of the SSIMULACRA2 scores, thus perfectly overlapping computing and decoding. In such scenario, skipping the computation of any frames would not make sense anymore, as no speed advantage would be obtained from it. However, this is still far from being a reality, as a speedup of at least \xd710.31 is needed for an RTX 4060 to match its decoding speeds with a computation stride of 1."}),"\n",(0,n.jsx)(t.h2,{id:"short-discussion-on-scoring-error",children:"Short discussion on scoring error"}),"\n",(0,n.jsx)(t.p,{children:'My original idea for this blog entry was to evaluate TurboMetrics both in terms of performance and scoring error. By "scoring error" I mean "the difference between the scores a CPU reference provides, and the ones TurboMetrics provides". However, once the first draft for that original version of this blog entry was completed, I realized I was not satisfied with the methodology followed and conclusions extracted from that second experiment. Therefore, I am putting off that evaluation for a second blog entry, that I will write once I make a new, bigger, and better, evaluation of the error.'}),"\n",(0,n.jsxs)(t.p,{children:["The main concern about the error the GPU computation incurs on SSIMULACRA2 scores is that SSIMULACRA2 scores have been tuned mathematically to correlate with visual quality, while the GPU implementation's scores ",(0,n.jsx)(t.em,{children:"try to mimic"}),' those scores, but have not undergone any kind of mathematical tuning or assessment themselves. The GPU scores could be seen as "SSIMULACRA2 + random error", and that "random error" might break the desired correlation, thus reducing the reliability of the metric.']}),"\n",(0,n.jsxs)(t.p,{children:['Nevertheless, it is worth noting that SSIMULACRA2 is not by any means a kind of "perfect metric" or "absolute truth" about video quality assessment. ',(0,n.jsx)(t.strong,{children:"SSIMULACRA2 still is unreliable in some situations, and it does not always present a perfect correlation with visual observations"}),'. You may find here and there specific examples of SSIMULACRA2 scores that do not accurately reflect the (perceived) quality of a compressed image or video. Besides, we should keep in mind that quality is a subjective matter. In that regard, and as an example, people who do not care much about film grain might give denoised videos higher quality scores than those that SSIMULACRA2 gives. (Other metrics, such as VMAF, are more tolerant to denoising.) With all this in mind, the results provided by TurboMetrics are not necessarily "incorrect", but rather provide a kind of "',(0,n.jsx)(t.strong,{children:"alternative metric"}),'".']}),"\n",(0,n.jsx)(t.p,{children:"Just to give a preview on the error evaluation thus far, I will share the following: The preliminary results I obtained from that now-scraped evaluation seem to indicate that:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The scores provided by the GPU implementation of SSIMULACRA2 are ",(0,n.jsx)(t.strong,{children:"statistically different"})," to the real scores (provided by the CPU implementations)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"No linear correlation"})," between the real scores and the GPU scores has been found."]}),"\n",(0,n.jsxs)(t.li,{children:["TurboMetrics ",(0,n.jsx)(t.strong,{children:"might tend to under-score"}),", compared to the real scores (i.e., the results for the frames tend to be lower than those a CPU implementation gives). This has yet to be assessed over a larger sample size to prove if it is really true, though."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["I am looking for help with the error evaluation for the follow-up blog entry. Mainly, I need a considerably larger sample of SSIMULACRA2 scores for videos, computed both in CPU and GPU. I myself do not have enough material (encoded videos and/or the SSIMULACRA2 scores for all their frames) yet to do a sufficiently good evaluation, and it would take me quite some time to get it. Thus, I am looking for anyone who has saved the SSIMULACRA2 scores for all the frames of any video they had assessed, and is able to re-assess those same videos using TurboMetrics. If you think you can help, and are willing to, please contact me through the ",(0,n.jsx)(t.a,{href:"https://discord.gg/bbQD5MjDr3",children:"AV1 for Dummies Discord server"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"overall-conclusions-and-final-thoughts",children:"Overall conclusions and final thoughts"}),"\n",(0,n.jsx)(t.p,{children:"In this blog entry, we have tested the GPU implementation of SSIMULACRA2 available through TurboMetrics, in terms of performance (i.e., scores computed per unit of time). The main conclusions are the following:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["All in all, TurboMetrics provides ",(0,n.jsx)(t.strong,{children:"impressive acceleration"})," of the SSIMULACRA2 computation."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"The performance of TurboMetrics does not scale linearly with the computational stride/frame skipping"}),". When increasing the stride, a point of diminishing returns is reached rather soon.","\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"This is caused by the time taken to decode the video frames, which is non-negligible, and becomes the bottleneck when computing SSIMULACRA2 so fast and only for some of the frames."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Hardware acceleration of computationally-intensive tasks is an important topic nowadays in several fields, especially considering how powerful current-day GPUs are; and I would hope for the teams developing these quality assessment metrics to consider it as an existing option. So far, only ",(0,n.jsx)(t.a,{href:"https://github.com/fraunhoferhhi/xpsnr",children:"XPSNR"})," has seemed to be concerned about computational complexity from the beginning, and the developers' response was not to consider hardware acceleration, but rather to simplify the design of their metric."]}),"\n",(0,n.jsxs)(t.p,{children:["After developing this blog entry, ",(0,n.jsx)(t.strong,{children:"my own recommendation"})," for assessing videos using SSIMULACRA2 would be to ",(0,n.jsx)(t.strong,{children:"use TurboMetrics, with a stride of 3 or 5 frames"}),". If you are willing to tolerate the error incurred by the GPU implementation, you should tolerate the error incurred by skipping frames, which probably is an order of magnitude lower. Of course, you should not take my recommendations blindly, and you should try it out yourself to see what works for you, and what you can tolerate."]}),"\n",(0,n.jsx)(t.h2,{id:"future",children:"Future"}),"\n",(0,n.jsx)(t.p,{children:"TurboMetrics' development is still ongoing, and I know Gui-Yom has tons of ideas for it. To begin with, I know the following ideas are being worked on:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"Support for GPUs of other vendors (AMD, Intel)."}),"\n",(0,n.jsx)(t.li,{children:"Support for FFmpeg piping, to enable working with videos of any codec."}),"\n",(0,n.jsx)(t.li,{children:"GPU acceleration of XPSNR."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"All these features would improve TurboMetrics significantly, while also opening the door for more tests to be performed. Additionally, as it has been mentioned in this blog entry, the SSIMULACRA2 computation can still be optimized further, including overlapping computation and decoding. Gui-Yom knows this, and plans to tackle that issue eventually."}),"\n",(0,n.jsxs)(t.p,{children:["A list of features to improve TurboMetrics' computation of SSIMULACRA2, written by the main developer, can be found ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics/blob/master/crates/ssimulacra2-cuda/README.md#how-to-do-better-",children:"here"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["As I said earlier, I also plan to write a follow-up blog entry evaluating the scoring error incurred in the GPU implementation, to test the reliability of the scores provided by TurboMetrics. Additionally, it may be insightful to evaluate the error for GPU implementations of other video metrics, such as ",(0,n.jsx)(t.a,{href:"https://github.com/Netflix/vmaf/blob/master/libvmaf/README.md",children:"VMAF CUDA"}),", and see if we find any similarities. I do not recall reading any analysis on the matter for other metrics, either. Nevertheless, I cannot give a date yet for when that follow-up blog entry might come out. I reckon it will take quite some time to perform the required experimentation, as well as processing and analyzing the results."]}),"\n",(0,n.jsx)(t.p,{children:"Also, this blog entry is heavily missing information on 4K video, which I believe to be of high interest. The main reason for it is that most 4K content is served using HEVC, and TurboMetrics still does not support that codec. When support for it gets added, experiments with 4K video should be conducted."}),"\n",(0,n.jsxs)(t.p,{children:["If you like TurboMetrics and have knowledge about programming, please consider ",(0,n.jsx)(t.a,{href:"https://github.com/Gui-Yom/turbo-metrics",children:"contributing to it"})," to the best of your ability. Together, we can make it even more awesome than it already is!"]}),"\n",(0,n.jsx)(t.p,{children:"And, lastly, thank you very much for reading!"}),"\n",(0,n.jsx)(t.h4,{id:"special-thanks",children:"Special thanks"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Gui-Yom"}),", for developing TurboMetrics, and also for proofreading and green-lighting this blog entry."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Trix"}),", for linking me to the Python script to easily compute SSIMULACRA2 using vszip (ssimulacravszip.py), and for helping me to get it to work the way I needed."]}),"\n"]}),"\n"]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},4273:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/ssimu2_cpu-gpu_comp-14d9d4adf53a5f52d954f652cb2edda6.svg"},4892:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/ssimu2_cpu-gpu_dec-36358329899ad37abff7f26b77bf01e1.svg"},8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>a});var i=s(6540);const n={},r=i.createContext(n);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);