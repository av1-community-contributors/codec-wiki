"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[274],{530:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"video/FFV1","title":"FFV1","description":"This section is in need of contributions. If you believe you can help, please see our Contribution Guide to get started as a contributor!","source":"@site/docs/video/FFV1.mdx","sourceDirName":"video","slug":"/video/FFV1","permalink":"/docs/video/FFV1","draft":false,"unlisted":false,"editUrl":"https://github.com/av1-community-contributors/codec-wiki/tree/main/docs/video/FFV1.mdx","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"title":"FFV1","sidebar_position":12},"sidebar":"tutorialSidebar","previous":{"title":"Theora","permalink":"/docs/video/Theora"},"next":{"title":"UT Video","permalink":"/docs/video/utvideo"}}');var s=n(4848),o=n(8453);const r={title:"FFV1",sidebar_position:12},c="FFV1",d={},a=[{value:"History",id:"history",level:2},{value:"Usage",id:"usage",level:2},{value:"Options",id:"options",level:3},{value:"Intra-frame only catch",id:"intra-frame-only-catch",level:2}];function l(e){const i={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"ffv1",children:"FFV1"})}),"\n",(0,s.jsx)(i.admonition,{title:"Help Wanted",type:"danger",children:(0,s.jsxs)(i.p,{children:["This section is in need of contributions. If you believe you can help, please see our ",(0,s.jsx)(i.a,{href:"/docs/contribution-guide",children:"Contribution Guide"})," to get started as a contributor!"]})}),"\n",(0,s.jsxs)(i.p,{children:["FFV1 (",(0,s.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc9043",children:"rfc9043"}),") is a lossless intra-frame video codec designed for archival use and preservation. Created by Michael Niedermayer, it is part of the ",(0,s.jsx)(i.a,{href:"/docs/utilities/ffmpeg",children:"FFmpeg"})," project. The codec supports a wide range of color spaces, works with YUV and RGB content including alpha channel of color depths ranging from 8 to 16 bits (only up to 14 in case of RGB). It has good parallelization support and achieves very high compression ratios compared to other lossless video encoders such as ",(0,s.jsx)(i.a,{href:"/docs/video/utvideo",children:"UT Video"}),", albeit at the cost of being more resource-hungry."]}),"\n",(0,s.jsx)(i.h2,{id:"history",children:"History"}),"\n",(0,s.jsx)(i.p,{children:"In 2003, the codec was merged into FFmpeg; however, the bitstream specification was frozen in 2006 (officially FFV1 version 0). Later, in 2009, version 1 came out, covering more video bit depths. Version 2 never got its release, existing only in experimental form."}),"\n",(0,s.jsx)(i.p,{children:"The third bitstream version was frozen in 2013 and is still the latest as of 2024. It added multithreading support and frame integrity checking."}),"\n",(0,s.jsxs)(i.p,{children:["There is a fourth version ",(0,s.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/draft-ietf-cellar-ffv1-v4/",children:"coming"})," which might bring better support for color spaces, compression improvements, and maybe proper inter-frame prediction."]}),"\n",(0,s.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",metastring:'title="Fast, heavily multithreaded"',children:"ffmpeg -i input.mkv -c:v ffv1 -slices 16 out.mkv\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",metastring:'title="Slow, highest compression"',children:"ffmpeg -i input.mkv -c:v ffv1 -g 60 -slices 4 -context 1 -coder 2 out.mkv\n"})}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",metastring:'title="Recommended for archival purposes, high compression, multithreaded"',children:"ffmpeg -i input.mkv -c:v ffv1 -g 1 -slices 16 -slicecrc 1 -context 1 -coder 2 out.mkv\n"})}),"\n",(0,s.jsx)(i.h3,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"slices"})," - Slices divide the frame into multiple parts that can be encoded and decoded in parallel. Can only be one of: [",(0,s.jsx)(i.code,{children:"4"}),", ",(0,s.jsx)(i.code,{children:"6"}),", ",(0,s.jsx)(i.code,{children:"9"}),", ",(0,s.jsx)(i.code,{children:"12"}),", ",(0,s.jsx)(i.code,{children:"16"}),", ",(0,s.jsx)(i.code,{children:"24"}),", ",(0,s.jsx)(i.code,{children:"30"}),"], where ",(0,s.jsx)(i.code,{children:"4"})," is the default."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"slicecrc"})," - Setting it to ",(0,s.jsx)(i.code,{children:"1"})," will enable the decoder to detect errors in the bitstream. Must be enabled for archival use. Can be either ",(0,s.jsx)(i.code,{children:"0"})," or ",(0,s.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"context"})," - Setting it to ",(0,s.jsx)(i.code,{children:"1"})," will make the encoder use a larger context size, which usually leads to better compression. Can be either ",(0,s.jsx)(i.code,{children:"0"})," or ",(0,s.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"coder"})," - Sets entropy coding method:","\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"0"})," - Golomb-Rice (faster, default)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"1"})," - Range Coder (used for higher bit depths and better compression)"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"2"})," - Range Coder with custom state transition table (almost the same as ",(0,s.jsx)(i.code,{children:"1"}),")"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"g"})," - Sets GOP size. Must be ",(0,s.jsx)(i.code,{children:"1"})," for archival use. ",(0,s.jsx)(i.a,{href:"#intra-frame-only-catch",children:"See below"})]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"intra-frame-only-catch",children:"Intra-frame only catch"}),"\n",(0,s.jsxs)(i.p,{children:["Intra-frame codecs do not use well known inter-frame video coding techniques such as motion compensation, reusing parts of surrounding frames or adapting encoding context based on them. Every frame is independent from one another. Common intra-frame codecs include Motion JPEG (Lossy), Motion JPEG 2000 (Both), and ",(0,s.jsx)(i.a,{href:"/docs/video/utvideo",children:"UT Video"})," (Lossless)."]}),"\n",(0,s.jsxs)(i.p,{children:["If you're a careful reader, you might have noticed that setting ",(0,s.jsx)(i.code,{children:"GOP size"})," isn't a common characteristic among intra-frame codecs."]}),"\n",(0,s.jsxs)(i.p,{children:["In fact, FFV1 can be considered an intra-frame codec only if the ",(0,s.jsx)(i.code,{children:"GOP size"})," is set to ",(0,s.jsx)(i.code,{children:"1"}),". When it's larger than that, its context model depends on other frames found within the GOP, which contradicts the definition of intra-frame video codec. That is why it's highly advised to set ",(0,s.jsx)(i.code,{children:"GOP size"})," to ",(0,s.jsx)(i.code,{children:"1"})," for archiving. This way, if a single frame gets damaged, you'll\nonly lose that frame. If ",(0,s.jsx)(i.code,{children:"GOP size"})," was large, you might lose much bigger part of the video."]}),"\n",(0,s.jsx)(i.p,{children:"References:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/FFV1",children:"Wikipedia"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://datatracker.ietf.org/doc/html/rfc9043",children:"RFC9043"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://trac.ffmpeg.org/wiki/Encode/FFV1",children:"FFmpeg Docs"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://forum.shotcut.org/t/exporting-as-ffv1-change-form-to-support-lossless-parameters/41230/19?page=2",children:"This Thread"})}),"\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"https://video.stackexchange.com/questions/24874/what-does-the-context-parameter-mean-when-using-ffv1-in-ffmpeg",children:"This Question"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>c});var t=n(6540);const s={},o=t.createContext(s);function r(e){const i=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:i},e.children)}}}]);