"use strict";(self.webpackChunkcodec_wiki=self.webpackChunkcodec_wiki||[]).push([[5415],{8309:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"images/WebP","title":"WebP","description":"WebP is a free image file format first released by Google in 2010. It consists of 2 primary \\"modes\\" of operation. A lossy mode derived from the VP8 video codec, and a novel lossless mode added in 2011.","source":"@site/docs/images/WebP.mdx","sourceDirName":"images","slug":"/images/WebP","permalink":"/docs/images/WebP","draft":false,"unlisted":false,"editUrl":"https://github.com/av1-community-contributors/codec-wiki/tree/main/docs/images/WebP.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"WebP","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"HEIC","permalink":"/docs/images/HEIC"},"next":{"title":"JPEG 2000","permalink":"/docs/images/JPEG2000"}}');var n=i(4848),r=i(8453);const t={title:"WebP",sidebar_position:4},a="WebP",l={},d=[{value:"Performance Checklist",id:"performance-checklist",level:2},{value:"History",id:"history",level:2},{value:"Adoption",id:"adoption",level:3},{value:"Criticism",id:"criticism",level:3},{value:"Vulnerabilities",id:"vulnerabilities",level:3},{value:"WebP 2",id:"webp-2",level:3},{value:"Technical Details",id:"technical-details",level:2},{value:"Lossy",id:"lossy",level:3},{value:"Lossless",id:"lossless",level:3},{value:"Extended Format Features",id:"extended-format-features",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const s={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"webp",children:"WebP"})}),"\n",(0,n.jsxs)(s.p,{children:['WebP is a free image file format first released by Google in 2010. It consists of 2 primary "modes" of operation. A lossy mode derived from the ',(0,n.jsx)(s.a,{href:"/docs/video/VP8",children:"VP8"})," video codec, and a novel lossless mode added in 2011."]}),"\n",(0,n.jsx)(s.h2,{id:"performance-checklist",children:"Performance Checklist"}),"\n",(0,n.jsxs)(s.p,{children:["Lossless? ",(0,n.jsx)(s.em,{children:"Yes"})]}),"\n",(0,n.jsxs)(s.p,{children:["Lossy? ",(0,n.jsx)(s.em,{children:"Yes"})]}),"\n",(0,n.jsxs)(s.p,{children:["Supported Bit Depth:\n",(0,n.jsx)(s.em,{children:"8 BPC"})]}),"\n",(0,n.jsxs)(s.p,{children:["HDR/Wide Gamut? ",(0,n.jsx)(s.em,{children:"No"})]}),"\n",(0,n.jsxs)(s.p,{children:["Animation? ",(0,n.jsx)(s.em,{children:"Yes"})]}),"\n",(0,n.jsxs)(s.p,{children:["Transparency? ",(0,n.jsx)(s.em,{children:"Yes"})]}),"\n",(0,n.jsxs)(s.p,{children:["Progressive Decode? ",(0,n.jsx)(s.em,{children:"No"})]}),"\n",(0,n.jsxs)(s.p,{children:["Royalty Free? ",(0,n.jsx)(s.em,{children:"Yes"})]}),"\n",(0,n.jsx)(s.h2,{id:"history",children:"History"}),"\n",(0,n.jsx)(s.p,{children:"Google announced the WebP format on 30 September 2010. It was initially proposed as a new open format for lossy compressed true-color graphics on the web, aiming to create files that were smaller than comparable JPEG files while maintaining similar image quality. The foundation of WebP utilized technology acquired by Google during its purchase of On2 Technologies. WebP is closely related to VP8, serving as a derivative, and is a sister project to the WebM multimedia container format. The reference library (libwebp) is released under a BSD free software license."}),"\n",(0,n.jsx)(s.p,{children:"Additional features were added after the initial release:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Extended File Format (October 2011): An extension enabling WebP to support features like animation, embedding an ICC profile, and including XMP and Exif metadata. This format also initially supported tiling, but that was later removed."}),"\n",(0,n.jsx)(s.li,{children:"Lossless Compression and Transparency (November 2011): Google announced a new lossless compression mode and the ability to support transparency (alpha channel) in both lossy & lossless modes. This support was enabled by default in libwebp, starting with version 0.2.0 on 16 August 2012. Google's initial benchmarks showed that converting PNG files found on the web to lossless WebP resulted in a 45% reduction in file size."}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"adoption",children:"Adoption"}),"\n",(0,n.jsxs)(s.p,{children:["libwebp is developed by Google, and reached version 1.0 in April 2018. In November 2024, WebP was formally specified and published by the IETF as ",(0,n.jsx)(s.a,{href:"https://www.rfc-editor.org/rfc/rfc9649",children:"RFC 9649"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["WebP has seen widespread adoption across the internet to reduce image sizes. ",(0,n.jsx)(s.a,{href:"https://caniuse.com",children:"caniuse.com"})," reports that over ",(0,n.jsx)(s.a,{href:"https://caniuse.com/?search=webp",children:"95% of web browsers fully support WebP"}),". Support has also grown across various software programs since 2010."]}),"\n",(0,n.jsx)(s.h3,{id:"criticism",children:"Criticism"}),"\n",(0,n.jsx)(s.p,{children:"Despite its adoption, WebP has faced criticism:"}),"\n",(0,n.jsxs)(s.p,{children:["Critics, including ",(0,n.jsx)(s.a,{href:"https://research.mozilla.org/2014/07/15/mozilla-advances-jpeg-encoding-with-mozjpeg-2-0/",children:"Josh Aas from Mozilla Research"}),' in 2014, have questioned whether the format offers significant speed benefits, noting that studies were "not able to conclude that WebP outperformed JPEG by any significant margin". Early critiques in 2010 noted that the quality of WebP-encoded results could be poor, particularly due to blurriness, arguing that the encoder attempted to optimize too hard for ',(0,n.jsx)(s.a,{href:"/docs/metrics/PSNR",children:"PSNR"})," rather than ",(0,n.jsx)(s.a,{href:"/docs/introduction/psychovisual",children:"psychovisual quality"}),". There is apparently an attempt to address this issue in the form of Halide Compression's ",(0,n.jsx)(s.a,{href:"https://halide.cx/iris/",children:"Iris-WebP"})," encoder released in 2025, though performance claims cannot be directly validated due to the encoder's proprietary nature."]}),"\n",(0,n.jsx)(s.p,{children:'The biggest challenge facing WebP\'s reputation has been lack of compatibility with older software, and the practice of content delivery networks replacing source JPEG/PNG files with WebP versions have been cited as making the format "user-unfriendly". Users who download images often find they must convert the file format later.'}),"\n",(0,n.jsx)(s.h3,{id:"vulnerabilities",children:"Vulnerabilities"}),"\n",(0,n.jsxs)(s.p,{children:["In September 2023, critical vulnerabilities were discovered relating to WebP images in libwebp's decoder. ",(0,n.jsx)(s.a,{href:"https://www.cve.org/CVERecord?id=CVE-2023-4863",children:"CVE-2023-4863"}),", was actively exploited and carried a high-risk rating (CVSS 8.8). This flaw could be triggered by a maliciously crafted lossless WebP file, potentially causing an overflow condition that could result in denial of service or remote code execution. The extensive use of libwebp across major browsers posed a patching challenge as well."]}),"\n",(0,n.jsx)(s.h3,{id:"webp-2",children:"WebP 2"}),"\n",(0,n.jsxs)(s.p,{children:["In June 2021, Google began developing WebP 2, intended to achieve better compression ratios while providing faster encoding and decoding speeds than other modern formats. However, in October 2022 Google changed ",(0,n.jsx)(s.a,{href:"https://chromium.googlesource.com/codecs/libwebp2/",children:"the development repository"}),'\'s README file to state that "WebP 2 would not be released as an image format."']}),"\n",(0,n.jsx)(s.h2,{id:"technical-details",children:"Technical Details"}),"\n",(0,n.jsxs)(s.p,{children:["The WebP file format is based on the ",(0,n.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Resource_Interchange_File_Format",children:"Resource Interchange File Format"})," (RIFF). The file structure is composed of chunks, each identified by a 32-bit FourCC (four-character code) and followed by a 32-bit size field indicating the payload size. The WebP container allows for features beyond a single VP8 key frame. The side length of WebP images is limited to 16,383 pixels squared."]}),"\n",(0,n.jsx)(s.p,{children:"WebP uses two primary compression schemes: lossy (based on VP8) and lossless (novel)."}),"\n",(0,n.jsx)(s.h3,{id:"lossy",children:"Lossy"}),"\n",(0,n.jsxs)(s.p,{children:["See the ",(0,n.jsx)(s.a,{href:"/docs/video/VP8",children:"VP8"})," page for more information."]}),"\n",(0,n.jsx)(s.h3,{id:"lossless",children:"Lossless"}),"\n",(0,n.jsx)(s.admonition,{title:"Lossless Compression",type:"note",children:(0,n.jsxs)(s.p,{children:["If you would like to dive more deeply into the topic of lossless compression, you can check out the ",(0,n.jsx)(s.a,{href:"/docs/introduction/lossless",children:"Lossless Compression"})," entry in the Introduction section of the wiki."]})}),"\n",(0,n.jsx)(s.p,{children:'WebP\'s lossless compression uses a newer algorithm designed by Google software engineer Jyrki Alakuijala, which is unrelated to VP8. Simple lossless WebP files use a RIFF container followed by a "VP8L" chunk containing the VP8L bitstream data.'}),"\n",(0,n.jsxs)(s.p,{children:["Lossless WebP supports ",(0,n.jsx)(s.strong,{children:"8-bit RGBA"})," (red, green, blue, alpha) color space exclusively. The format stores and restores pixel values exactly, even for fully transparent pixels. It relies on a universal algorithm for sequential data compression (LZ77), prefix coding (Huffman coding), and a color cache to compress bulk data."]}),"\n",(0,n.jsx)(s.p,{children:"The lossless mode employs dedicated entropy codes for different color channels, exploitation of 2D locality of backward reference distances, A color cache for recently used colors (which allows referencing them with shorter codes), and transforms such as the Predictor Transform, Color Transform, Subtract Green Transform, and Color Indexing Transform are applied before entropy coding to reduce symbolic entropy."}),"\n",(0,n.jsxs)(s.p,{children:["A distinctive aspect of the lossless format is its ",(0,n.jsx)(s.em,{children:"recursive definition"}),": control images used for functions like local entropy code selection are encoded using the same methods as the main image itself."]}),"\n",(0,n.jsx)(s.h3,{id:"extended-format-features",children:"Extended Format Features"}),"\n",(0,n.jsxs)(s.p,{children:["The WebP container format (the RIFF container for WebP) enables several advanced features collectively known as the ",(0,n.jsx)(s.em,{children:"Extended File Format"}),"."]}),"\n",(0,n.jsx)(s.p,{children:"WebP supports animation, which is promoted by Google as an alternative to GIF. Animated WebP supports 24-bit color depth with transparency, allows combining frames using both lossy and lossless compression within the same animation, and supports seeking to specific frames. The animation parameters are managed by:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"A 'VP8X' chunk to indicate the extended WebP spec"}),"\n",(0,n.jsx)(s.li,{children:"An 'ANIM' Chunk containing global parameters, such as the background color & loop count (0 = infinite loops)"}),"\n",(0,n.jsx)(s.li,{children:"Multiple 'ANMF' Chunks: Contain information for a single frame, including its position, duration, blending method (alpha-blending or overwrite), and disposal method (leave canvas as is, or dispose to background color)."}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Converting animated GIFs to lossy WebP can reportedly reduce file size by 64%."}),"\n",(0,n.jsx)(s.p,{children:"Additionally, transparency information is supported through an alpha channel. In the extended format, alpha data for lossy images is stored in an optional 'ALPH' chunk. This data can be stored as raw 8-bit transparency values or compressed using the WebP lossless format."}),"\n",(0,n.jsx)(s.p,{children:"The extended format also allows embedding metadata and color profiles. An image may contain an embedded ICC profile, described by the International Color Consortium. If not present, sRGB is assumed. Metadata can be stored in Exif or XMP formats, placed in optional 'EXIF' or 'XMP' chunks."}),"\n",(0,n.jsxs)(s.p,{children:["The RIFF container allows for the inclusion of ",(0,n.jsx)(s.em,{children:"unknown chunks"})," (FourCCs not defined in the specification) for future extensions or application-specific data. Readers should ignore these chunks, and writers should preserve them."]}),"\n",(0,n.jsx)(s.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsxs)(s.p,{children:["WebP is largely succeeded by ",(0,n.jsx)(s.a,{href:"/docs/images/AVIF",children:"AVIF"}),", and the libwebp encoder has not received adequate psychovisual attention to compete with more technically advanced encoders like ",(0,n.jsx)(s.a,{href:"/docs/encoders/aomenc",children:"libaom"})," or more well-optimized perceptual encoders like Google's ",(0,n.jsx)(s.a,{href:"https://github.com/google/jpegli",children:"jpegli"})," JPEG encoder."]}),"\n",(0,n.jsxs)(s.p,{children:["While a lot of WebP's original criticisms aren't as relevant in 2025, the three biggest issues with the format that have historically drawn the most ire (lack of support, vulnerabilities, poor perceptual encoding) have marred WebP's reputation in a way that the community may not reconcile for a long time, if ever. Especially since the Chromium browser engine's removal of the ",(0,n.jsx)(s.a,{href:"/docs/images/JXL",children:"JPEG XL"})," image format (effectively killing widespread web adoption), new video-derived web image codecs sit in an uncomfortable place, and WebP is the poster child of this unfortunate discomfort."]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>t,x:()=>a});var o=i(6540);const n={},r=o.createContext(n);function t(e){const s=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:t(e.components),o.createElement(r.Provider,{value:s},e.children)}}}]);